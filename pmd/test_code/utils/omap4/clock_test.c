#include <linux/init.h>
#include <linux/module.h>
#include <linux/clk.h>
#include <linux/err.h>
#include <plat/clock.h>
#include <plat/cpu.h>

MODULE_LICENSE("GPL");

static uint test_id = 0;
module_param (test_id, int, S_IRUGO|S_IWUSR);

struct clk_info {
	const char *dev_id;
	const char *con_id;
};

/*
 * This is autogenerated using the H/W db.
 * Do not manually edit.
 */
static struct clk_info clks[] = {
	{NULL, "extalt_clkin_ck"},
	{NULL, "pad_clks_ck"},
	{NULL, "pad_slimbus_core_clks_ck"},
	{NULL, "secure_32k_clk_src_ck"},
	{NULL, "slimbus_clk"},
	{NULL, "sys_32k_ck"},
	{NULL, "tie_low_clock_ck"},
	{NULL, "virt_12000000_ck"},
	{NULL, "virt_13000000_ck"},
	{NULL, "virt_16800000_ck"},
	{NULL, "virt_19200000_ck"},
	{NULL, "virt_26000000_ck"},
	{NULL, "virt_27000000_ck"},
	{NULL, "virt_38400000_ck"},
	{NULL, "sys_clkin_ck"},
	{NULL, "utmi_phy_clkout_ck"},
	{NULL, "xclk60mhsp1_ck"},
	{NULL, "xclk60mhsp2_ck"},
	{NULL, "xclk60motg_ck"},
	{NULL, "abe_dpll_bypass_clk_mux_ck"},
	{NULL, "abe_dpll_refclk_mux_ck"},
	{NULL, "dpll_abe_ck"},
	{NULL, "dpll_abe_m2x2_ck"},
	{NULL, "abe_24m_fclk"},
	{NULL, "abe_clk"},
	{NULL, "aess_fclk"},
	{NULL, "dpll_abe_m3_ck"},
	{NULL, "core_hsd_byp_clk_mux_ck"},
	{NULL, "dpll_core_ck"},
	{NULL, "dpll_core_m6_ck"},
	{NULL, "dbgclk_mux_ck"},
	{NULL, "ddrphy_ck"},
	{NULL, "dpll_core_m5_ck"},
	{NULL, "div_core_ck"},
	{NULL, "div_iva_hs_clk"},
	{NULL, "div_mpu_hs_clk"},
	{NULL, "dpll_core_m4_ck"},
	{NULL, "dll_clk_div_ck"},
	{NULL, "dpll_abe_m2_ck"},
	{NULL, "dpll_core_m3_ck"},
	{NULL, "dpll_core_m7_ck"},
	{NULL, "iva_hsd_byp_clk_mux_ck"},
	{NULL, "dpll_iva_ck"},
	{NULL, "dpll_iva_m4_ck"},
	{NULL, "dpll_iva_m5_ck"},
	{NULL, "dpll_mpu_ck"},
	{NULL, "dpll_mpu_m2_ck"},
	{NULL, "per_hs_clk_div_ck"},
	{NULL, "per_hsd_byp_clk_mux_ck"},
	{NULL, "dpll_per_ck"},
	{NULL, "dpll_per_m2_ck"},
	{NULL, "dpll_per_m2x2_ck"},
	{NULL, "dpll_per_m3_ck"},
	{NULL, "dpll_per_m4_ck"},
	{NULL, "dpll_per_m5_ck"},
	{NULL, "dpll_per_m6_ck"},
	{NULL, "dpll_per_m7_ck"},
	{NULL, "usb_hs_clk_div_ck"},
#if 0
	{NULL, "dpll_usb_ck"},
#endif
	{NULL, "dpll_usb_clkdcoldo_ck"},
	{NULL, "dpll_usb_m2_ck"},
	{NULL, "func_12m_fclk"},
	{NULL, "func_24m_clk"},
	{NULL, "func_24mc_fclk"},
	{NULL, "func_48m_fclk"},
	{NULL, "func_48mc_fclk"},
	{NULL, "func_64m_fclk"},
	{NULL, "func_96m_fclk"},
	{NULL, "hsmmc6_fclk"},
	{NULL, "init_60m_fclk"},
	{NULL, "l3_div_ck"},
	{NULL, "l4_div_ck"},
	{NULL, "lp_clk_div_ck"},
	{NULL, "l4_wkup_clk_mux_ck"},
	{NULL, "per_abe_nc_fclk"},
	{NULL, "mcasp2_fclk"},
	{NULL, "mcasp3_fclk"},
	{NULL, "ocp_abe_iclk"},
	{NULL, "per_abe_24m_fclk"},
	{NULL, "pmd_stm_clock_mux_ck"},
	{NULL, "pmd_trace_clk_mux_ck"},
	{NULL, "syc_clk_div_ck"},
	{NULL, "aes1_fck"},
	{NULL, "aes2_fck"},
	{NULL, "aess_fck"},
	{NULL, "cust_efuse_fck"},
	{NULL, "des3des_fck"},
	{NULL, "dmic_sync_mux_ck"},
	{NULL, "dmic_fck"},
	{NULL, "dss_fck"},
	{NULL, "ducati_ick"},
#if 0
	/* Cannot disable EMIF clocks */
	{NULL, "emif1_ick"},
	{NULL, "emif2_ick"},
#endif
	{NULL, "fdif_fck"},
	{NULL, "gfx_fck"},
	{"omap-gpio.0", "ick"},
	{"omap-gpio.1", "ick"},
	{"omap-gpio.2", "ick"},
	{"omap-gpio.3", "ick"},
	{"omap-gpio.4", "ick"},
	{"omap-gpio.5", "ick"},
	{NULL, "gpmc_ick"},
	{NULL, "gpt1_fck"},
	{NULL, "gpt10_fck"},
	{NULL, "gpt11_fck"},
	{NULL, "gpt2_fck"},
	{NULL, "gpt3_fck"},
	{NULL, "gpt4_fck"},
	{NULL, "gpt5_fck"},
	{NULL, "gpt6_fck"},
	{NULL, "gpt7_fck"},
	{NULL, "gpt8_fck"},
	{NULL, "gpt9_fck"},
	{"omap2_hdq.0", "fck"},
	{NULL, "hsi_ick"},
	{"i2c_omap.1", "fck"},
	{"i2c_omap.2", "fck"},
	{"i2c_omap.3", "fck"},
	{"i2c_omap.4", "fck"},
	{NULL, "iss_fck"},
	{NULL, "ivahd_ick"},
	{NULL, "keyboard_fck"},
	{NULL, "l3_instr_interconnect_ick"},
	{NULL, "l3_interconnect_3_ick"},
	{NULL, "mcasp_sync_mux_ck"},
	{NULL, "mcasp_fck"},
	{NULL, "mcbsp1_sync_mux_ck"},
	{NULL, "mcbsp2_sync_mux_ck"},
	{NULL, "mcbsp3_sync_mux_ck"},
	{NULL, "mcbsp4_sync_mux_ck"},
	{"omap2_mcspi.1", "fck"},
	{"omap2_mcspi.2", "fck"},
	{"omap2_mcspi.3", "fck"},
	{"omap2_mcspi.4", "fck"},
	{"mmci-omap-hs.2", "fck"},
	{"mmci-omap-hs.3", "fck"},
	{"mmci-omap-hs.4", "fck"},
	{NULL, "ocp_wp1_ick"},
	{NULL, "pdm_fck"},
	{NULL, "pkaeip29_fck"},
	{"omap_rng", "ick"},
	{NULL, "sha2md51_fck"},
	{NULL, "sl2_ick"},
	{NULL, "slimbus1_fck"},
	{NULL, "slimbus2_fck"},
	{NULL, "sr_core_fck"},
	{NULL, "sr_iva_fck"},
	{NULL, "sr_mpu_fck"},
	{NULL, "tesla_ick"},
	{NULL, "uart1_fck"},
	{NULL, "uart2_fck"},
#if 0
	{NULL, "uart3_fck"},
#endif
	{NULL, "uart4_fck"},
	{NULL, "usb_host_fck"},
	{NULL, "usb_host_fs_fck"},
	{"musb_hdrc", "ick"},
	{NULL, "usb_tll_ick"},
	{NULL, "usbphyocp2scp_ick"},
	{NULL, "usim_ick"},
	{"omap_wdt", "fck"},
	{NULL, "wdt3_fck"},
	{NULL, "otg_60m_gfclk_ck"},
	{NULL, "stm_clk_div_ck"},
	{NULL, "trace_clk_div_ck"},
	{NULL, "usim_fclk"},
	{NULL, "utmi_p1_gfclk_ck"},
	{NULL, "utmi_p2_gfclk_ck"},
};

int clk_test_opt1(void);
int clk_test_opt2(void);
int clk_test_opt3(void);
int clk_test_opt4(void);

static int clock_test_init(void)
{
	if (!cpu_is_omap44xx()) {
		printk(KERN_ERR "Test cases only supported on OMAP44XX platform\n");
		return 0;
	}

	printk ("******************* HELP ******************\n");
	printk ("USAGE: ./clock_test.ko test_id=\"option\"\n");
	printk ("Following are the valid test_id options\n");
	printk ("test_id=0x1 - Tests clk get/enable/disable/put\n");
	printk ("test_id=0x2 - Tests clk get_rate/set_rate/round_rate/set_parent\n");
	printk ("test_id=0x3 - Tests DPLL api's\n");
	printk ("test_id=0x4 - Negative tests for all clk api's\n");
	printk ("******************* HELP ******************\n");

	if (test_id == 0x1) {
		printk("Testing clk get/enable/disable/put\n");
		if (clk_test_opt1())
			printk(KERN_ERR "TEST FAILED\n");
		else
			printk(KERN_ERR "TEST PASSED\n");
		return 0;
	} else if (test_id == 0x2) {
		printk("Testing clk get_rate/set_rate/round_rate/set_parent\n");
		if (clk_test_opt2())
			printk(KERN_ERR "TEST FAILED\n");
		else
			printk(KERN_ERR "TEST PASSED\n");
		return 0;
	} else if (test_id == 0x3) {
		printk("Testing DPLL api's\n");
		if (clk_test_opt3())
			printk(KERN_ERR "TEST FAILED\n");
		else
			printk(KERN_ERR "TEST PASSED\n");
		return 0;
	} else if (test_id == 0x4) {
		printk("Testing Negative tests for all clk api's\n");
		if (clk_test_opt4())
			printk(KERN_ERR "TEST FAILED\n");
		else
			printk(KERN_ERR "TEST PASSED\n");
		return 0;
	} else {
		printk(KERN_ERR "Invalid Test Id\n");
		return 0;
	}
        printk(KERN_INFO "End of clock test\n");
        printk(KERN_INFO "Since clock settings are changed, Please reboot the system\n");
}

int clk_test_opt1(void)
{
	int i, ret = 0;
	struct clk *tclk;

	for (i = 0; i < ARRAY_SIZE(clks); i++) {
		printk(KERN_DEBUG "\nClock: %s, %s\n",
						clks[i].dev_id, clks[i].con_id);
		tclk = clk_get_sys(clks[i].dev_id, clks[i].con_id);
		if(IS_ERR(tclk)) {
			printk(KERN_ERR "clk_get failed for clk %s, %s\n",
						clks[i].dev_id, clks[i].con_id);
			ret = 1;
			continue;
		}

		printk("\nClk name: %s\n", tclk->name);

                ret = clk_enable(tclk);
                if (ret != 0)
                        printk(KERN_ERR
                               "Error: clk_enable for clock %s returned %d\n",
                               tclk->name, ret);
		else
			clk_disable(tclk);

		clk_put(tclk);
		tclk = NULL;
	}
	return ret;
}

int clk_test_opt2(void)
{
	int i, ret = 0;
	struct clk *tclk;
        unsigned long rate, valid_rate, orig_rate;

	for (i = 0; i < ARRAY_SIZE(clks); i++) {
		printk(KERN_DEBUG "\nClock: %s, %s\n",
						clks[i].dev_id, clks[i].con_id);
		tclk = clk_get_sys(clks[i].dev_id, clks[i].con_id);
		if(IS_ERR(tclk)) {
			printk(KERN_ERR "clk_get failed for clk %s, %s\n",
						clks[i].dev_id, clks[i].con_id);
			ret = 1;
			continue;
		}

		printk("\nClk name: %s\n", tclk->name);

                ret = clk_enable(tclk);
                if (ret != 0)
                        printk(KERN_ERR
                               "Error: clk_enable for clock %s returned %d\n",
                               tclk->name, ret);

		orig_rate = clk_get_rate(tclk);
                printk(KERN_INFO "Rate of clk %s is %lu\n", tclk->name,
                       tclk->rate);

		/* CORE DVFS not supported yet */
		if (!strcmp(tclk->name, "dpll_core_m2_ck") ||
				!strcmp(tclk->name, "dpll_core_m3_ck") ||
				!strcmp(tclk->name, "dpll_core_m4_ck") ||
				!strcmp(tclk->name, "dpll_core_m5_ck") ||
				!strcmp(tclk->name, "dpll_core_m6_ck") ||
				!strcmp(tclk->name, "dpll_core_m7_ck"))
			goto skip;

		/* Changing these rates cause UART non-functional */
		if (!strcmp(tclk->name, "func_48m_fclk") ||
				!strcmp(tclk->name, "func_64m_fclk") ||
				!strcmp(tclk->name, "func_96m_fclk") ||
				!strcmp(tclk->name, "dpll_per_m2x2_ck") ||
				!strcmp(tclk->name, "dpll_per_m2_ck") ||
				!strcmp(tclk->name, "dpll_per_ck") ||
				!strcmp(tclk->name, "per_abe_nc_fclk"))
			goto skip;

		if (tclk->set_rate) {
			/* Try double */
			/* Only if its not a DPLL, dplls cannot be locked at higher freq
			 * without scaling voltages */
			if (!tclk->dpll_data) {
				valid_rate = clk_round_rate(tclk, orig_rate * 2);
				/* Check if a valid rate exists */
				if (valid_rate != ~0) {
					printk(KERN_INFO "Trying to set %lu, closest possible\
						%lu\n", orig_rate * 2, valid_rate);
					clk_set_rate(tclk, valid_rate);
					printk(KERN_INFO "Rate of clk %s is %lu\n",
						tclk->name, rate);
				}
			}
			rate = clk_get_rate(tclk);
			/* Try half rate */
			valid_rate = clk_round_rate(tclk, orig_rate / 2);
			/* Check if a valid rate exists */
			if (valid_rate != ~0) {
				printk(KERN_INFO "Trying to set %lu, closest possible\
					%lu\n", orig_rate / 2, valid_rate);
				clk_set_rate(tclk, valid_rate);
				rate = clk_get_rate(tclk);
				printk(KERN_INFO "Rate of clk %s is %lu\n",
					tclk->name, rate);
			}
		}

skip:
                if (ret == 0) {
                        clk_disable(tclk);
			clk_put(tclk);
			tclk = NULL;
                }
	}
	return ret;
}

int clk_test_opt3(void)
{
	int i, ret = 0;
	struct clk *tclk;
        unsigned long rate, valid_rate;

	for (i = 0; i < ARRAY_SIZE(clks); i++) {
		printk(KERN_DEBUG "\nClock: %s, %s\n",
						clks[i].dev_id, clks[i].con_id);
		tclk = clk_get_sys(clks[i].dev_id, clks[i].con_id);
		if(IS_ERR(tclk)) {
			printk(KERN_ERR "clk_get failed for clk %s, %s\n",
						clks[i].dev_id, clks[i].con_id);
			ret = 1;
			continue;
		}

                ret = clk_enable(tclk);
                if (ret != 0)
                        printk(KERN_ERR
                               "Error: clk_enable for clock %s returned %d\n",
                               tclk->name, ret);

                if ((tclk->dpll_data)) {
			printk("\nClk name: %s\n", tclk->name);

			if (!strcmp(tclk->name, "dpll_core_ck") ||
					!strcmp(tclk->name, "dpll_per_ck"))
				goto skip;
                        printk("Testing round rate:\n");
                        /* Check closest possible rate to 300 Mhz */
                        valid_rate = clk_round_rate(tclk, 300000000);
                        printk("Valid rate when input is 300M: %lu\n",
								valid_rate);
			ret = clk_set_rate(tclk, valid_rate);
			printk("Set rate returned : %d for valid rate : %lu\n",
								ret, valid_rate);
                        rate = clk_get_rate(tclk);
                        printk(KERN_INFO "Rate of clk %s is %lu\n", tclk->name,
								tclk->rate);
                        /* Check closest possible rate to 200 Mhz */
                        valid_rate = clk_round_rate(tclk, 200000000);
                        printk("Valid rate when input is 200M: %lu\n",
								valid_rate);
                        ret = clk_set_rate(tclk, valid_rate);
                        printk("Set rate returned : %d for valid rate : %lu\n",
								ret, valid_rate);
                        rate = clk_get_rate(tclk);
                        printk(KERN_INFO "Rate of clk %s is %lu\n", tclk->name,
                               tclk->rate);

                        /* Check closest possible rate to 100 Mhz */
                        valid_rate = clk_round_rate(tclk, 100000000);
                        printk("Valid rate when input is 100M: %lu\n",
                               valid_rate);
                        ret = clk_set_rate(tclk, valid_rate);
                        printk("Set rate returned : %d for valid rate : %lu\n",
								ret, valid_rate);
                        rate = clk_get_rate(tclk);
                        printk(KERN_INFO "Rate of clk %s is %lu\n", tclk->name,
                               tclk->rate);
                }
skip:
                if (ret == 0) {
			clk_disable(tclk);
			clk_put(tclk);
			tclk = NULL;
		}
	}
	return ret;
}

int clk_test_opt4(void)
{
	struct clk *tclk;
	int ret, i;

	/* try getting a bogus clk */
	tclk = clk_get_sys(NULL, "bogus_clk");
	if(!IS_ERR(tclk)) {
		printk(KERN_ERR "negative tst for clk_get_sys failed");
		return -1;
	}

	for (i = 0; i < ARRAY_SIZE(clks); i++) {
		tclk = clk_get_sys(clks[i].dev_id, clks[i].con_id);
		if(IS_ERR(tclk)) {
			printk(KERN_ERR "clk_get failed for clk %s, %s\n",
						clks[i].dev_id, clks[i].con_id);
			ret = 1;
			continue;
		}
		if (tclk->set_rate) {
			ret = clk_set_rate(tclk, 0x0);
			if (ret != -EINVAL) {
				printk(KERN_ERR "negative tst for clk_get_sys failed");
				return -1;
			}
		}
	}

	return 0;
}

static void clock_test_exit(void)
{
}

module_init(clock_test_init);
module_exit(clock_test_exit);
